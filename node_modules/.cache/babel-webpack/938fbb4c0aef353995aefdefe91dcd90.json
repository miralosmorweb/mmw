{"ast":null,"code":"import { Subject, Observable, merge, ReplaySubject, combineLatest, animationFrameScheduler, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Output, EventEmitter, NgZone, Renderer2, Optional, Inject, ViewContainerRef, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, auditTime, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n\n}\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nDraggableHelper.ngInjectableDef = defineInjectable({\n  factory: function DraggableHelper_Factory() {\n    return new DraggableHelper();\n  },\n  token: DraggableHelper,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\n\n\nlet DraggableScrollContainerDirective = /*#__PURE__*/(() => {\n  class DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /**\n       * Trigger the DragStart after a long touch in scrollable container when true\n       * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n       */\n\n      this.activeLongPressDrag = false;\n      /**\n       * Configuration of a long touch\n       * Duration in ms of a long touch before activating DragStart\n       * Delta of the\n       * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n       */\n\n      this.longPressConfig = {\n        duration: 300,\n        delta: 30\n      };\n    }\n\n  }\n\n  DraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n    return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  DraggableScrollContainerDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableScrollContainerDirective,\n    selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n    inputs: {\n      activeLongPressDrag: \"activeLongPressDrag\",\n      longPressConfig: \"longPressConfig\"\n    }\n  });\n  /** @nocollapse */\n\n  return DraggableScrollContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\n\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    className => renderer.addClass(element.nativeElement, className));\n  }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\n\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    className => renderer.removeClass(element.nativeElement, className));\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DraggableDirective = /*#__PURE__*/(() => {\n  class DraggableDirective {\n    /**\n     * @hidden\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} vcr\n     * @param {?} scrollContainer\n     * @param {?} document\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n      this.element = element;\n      this.renderer = renderer;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.vcr = vcr;\n      this.scrollContainer = scrollContainer;\n      this.document = document;\n      /**\n       * The axis along which the element is draggable\n       */\n\n      this.dragAxis = {\n        x: true,\n        y: true\n      };\n      /**\n       * Snap all drags to an x / y grid\n       */\n\n      this.dragSnapGrid = {};\n      /**\n       * Show a ghost element that shows the drag when dragging\n       */\n\n      this.ghostDragEnabled = true;\n      /**\n       * Show the original element when ghostDragEnabled is true\n       */\n\n      this.showOriginalElementWhileDragging = false;\n      /**\n       * The cursor to use when hovering over a draggable element\n       */\n\n      this.dragCursor = '';\n      /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n\n      this.autoScroll = {\n        margin: 20\n      };\n      /**\n       * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n       */\n\n      this.dragPointerDown = new EventEmitter();\n      /**\n       * Called when the element has started to be dragged.\n       * Only called after at least one mouse or touch move event.\n       * If you call $event.cancelDrag$.emit() it will cancel the current drag\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Called after the ghost element has been created\n       */\n\n      this.ghostElementCreated = new EventEmitter();\n      /**\n       * Called when the element is being dragged\n       */\n\n      this.dragging = new EventEmitter();\n      /**\n       * Called after the element is dragged\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.pointerDown$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerMove$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerUp$ = new Subject();\n      this.eventListenerSubscriptions = {};\n      this.destroy$ = new Subject();\n      this.timeLongPress = {\n        timerBegin: 0,\n        timerEnd: 0\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.checkEventListeners();\n      /** @type {?} */\n\n      const pointerDragged$ = this.pointerDown$.pipe(filter(\n      /**\n      * @return {?}\n      */\n      () => this.canDrag()), mergeMap(\n      /**\n      * @param {?} pointerDownEvent\n      * @return {?}\n      */\n      pointerDownEvent => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        } // hack to prevent text getting selected in safari while dragging\n\n        /** @type {?} */\n\n\n        const globalDragStyle = this.renderer.createElement('style');\n        this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n        this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n        requestAnimationFrame(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.document.head.appendChild(globalDragStyle);\n        });\n        /** @type {?} */\n\n        const startScrollPosition = this.getScrollPosition();\n        /** @type {?} */\n\n        const scrollContainerScroll$ = new Observable(\n        /**\n        * @param {?} observer\n        * @return {?}\n        */\n        observer => {\n          /** @type {?} */\n          const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll',\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          e => observer.next(e));\n        }).pipe(startWith(startScrollPosition), map(\n        /**\n        * @return {?}\n        */\n        () => this.getScrollPosition()));\n        /** @type {?} */\n\n        const currentDrag$ = new Subject();\n        /** @type {?} */\n\n        const cancelDrag$ = new ReplaySubject();\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n        /** @type {?} */\n\n        const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n        /** @type {?} */\n\n        const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ([pointerMoveEvent, scroll]) => {\n          return {\n            currentDrag$,\n            transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n            transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n            clientX: pointerMoveEvent.clientX,\n            clientY: pointerMoveEvent.clientY,\n            scrollLeft: scroll.left,\n            scrollTop: scroll.top\n          };\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        moveData => {\n          if (this.dragSnapGrid.x) {\n            moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n          }\n\n          if (this.dragSnapGrid.y) {\n            moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        moveData => {\n          if (!this.dragAxis.x) {\n            moveData.transformX = 0;\n          }\n\n          if (!this.dragAxis.y) {\n            moveData.transformY = 0;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        moveData => {\n          /** @type {?} */\n          const scrollX = moveData.scrollLeft - startScrollPosition.left;\n          /** @type {?} */\n\n          const scrollY = moveData.scrollTop - startScrollPosition.top;\n          return Object.assign({}, moveData, {\n            x: moveData.transformX + scrollX,\n            y: moveData.transformY + scrollY\n          });\n        }), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          x,\n          y,\n          transformX,\n          transformY\n        }) => !this.validateDrag || this.validateDrag({\n          x,\n          y,\n          transform: {\n            x: transformX,\n            y: transformY\n          }\n        })), takeUntil(dragComplete$), share());\n        /** @type {?} */\n\n        const dragStarted$ = pointerMove.pipe(take(1), share());\n        /** @type {?} */\n\n        const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n        dragStarted$.subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          clientX,\n          clientY,\n          x,\n          y\n        }) => {\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.dragStart.next({\n              cancelDrag$\n            });\n          });\n          this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], Object.assign({}, this.autoScroll, {\n            /**\n            * @return {?}\n            */\n            autoScroll() {\n              return true;\n            }\n\n          }));\n          addClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (this.ghostDragEnabled) {\n            /** @type {?} */\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            /** @type {?} */\n\n            const clone = this.element.nativeElement.cloneNode(true);\n\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n            }\n\n            this.ghostElement = clone;\n            this.document.body.style.cursor = this.dragCursor;\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none'\n            });\n\n            if (this.ghostElementTemplate) {\n              /** @type {?} */\n              const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n              clone.innerHTML = '';\n              viewRef.rootNodes.filter(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              node => node instanceof Node).forEach(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              node => {\n                clone.appendChild(node);\n              });\n              dragEnded$.subscribe(\n              /**\n              * @return {?}\n              */\n              () => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(\n            /**\n            * @return {?}\n            */\n            () => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n            dragEnded$.subscribe(\n            /**\n            * @return {?}\n            */\n            () => {\n              clone.parentElement.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n        dragEnded$.pipe(mergeMap(\n        /**\n        * @param {?} dragEndData\n        * @return {?}\n        */\n        dragEndData => {\n          /** @type {?} */\n          const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n          /**\n          * @param {?} calledCount\n          * @return {?}\n          */\n          calledCount => Object.assign({}, dragEndData, {\n            dragCancelled: calledCount > 0\n          })));\n          cancelDrag$.complete();\n          return dragEndData$;\n        })).subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          x,\n          y,\n          dragCancelled\n        }) => {\n          this.scroller.destroy();\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.dragEnd.next({\n              x,\n              y,\n              dragCancelled\n            });\n          });\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n          currentDrag$.complete();\n        });\n        merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(\n        /**\n        * @return {?}\n        */\n        () => {\n          requestAnimationFrame(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.document.head.removeChild(globalDragStyle);\n          });\n        });\n        return pointerMove;\n      }), share());\n      merge(pointerDragged$.pipe(take(1), map(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([previous, next]) => {\n        if (!previous) {\n          return true;\n        }\n\n        return previous.x !== next.x || previous.y !== next.y;\n      }), map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([previous, next]) => next), auditTime(0, animationFrameScheduler)).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        x,\n        y,\n        currentDrag$,\n        clientX,\n        clientY,\n        transformX,\n        transformY\n      }) => {\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragging.next({\n            x,\n            y\n          });\n        });\n\n        if (this.ghostElement) {\n          /** @type {?} */\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n\n        currentDrag$.next({\n          clientX,\n          clientY,\n          dropData: this.dropData\n        });\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.dragAxis) {\n        this.checkEventListeners();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.unsubscribeEventListeners();\n      this.pointerDown$.complete();\n      this.pointerMove$.complete();\n      this.pointerUp$.complete();\n      this.destroy$.next();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    checkEventListeners() {\n      /** @type {?} */\n      const canDrag = this.canDrag();\n      /** @type {?} */\n\n      const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n      if (canDrag && !hasEventListeners) {\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          event => {\n            this.onMouseDown(event);\n          });\n          this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          event => {\n            this.onMouseUp(event);\n          });\n          this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          event => {\n            this.onTouchStart(event);\n          });\n          this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          event => {\n            this.onTouchEnd(event);\n          });\n          this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          event => {\n            this.onTouchEnd(event);\n          });\n          this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter',\n          /**\n          * @return {?}\n          */\n          () => {\n            this.onMouseEnter();\n          });\n          this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave',\n          /**\n          * @return {?}\n          */\n          () => {\n            this.onMouseLeave();\n          });\n        });\n      } else if (!canDrag && hasEventListeners) {\n        this.unsubscribeEventListeners();\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onMouseDown(event) {\n      if (event.button === 0) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n          /**\n          * @param {?} mouseMoveEvent\n          * @return {?}\n          */\n          mouseMoveEvent => {\n            this.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY\n            });\n          });\n        }\n\n        this.pointerDown$.next({\n          event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onMouseUp(event) {\n      if (event.button === 0) {\n        if (this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove();\n          delete this.eventListenerSubscriptions.mousemove;\n        }\n\n        this.pointerUp$.next({\n          event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onTouchStart(event) {\n      /** @type {?} */\n      let startScrollPosition;\n      /** @type {?} */\n\n      let isDragActivated;\n      /** @type {?} */\n\n      let hasContainerScrollbar;\n\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n        this.timeLongPress.timerBegin = Date.now();\n        isDragActivated = false;\n        hasContainerScrollbar = this.hasScrollbar();\n        startScrollPosition = this.getScrollPosition();\n      }\n\n      if (!this.eventListenerSubscriptions.touchmove) {\n        /** @type {?} */\n        const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        e => {\n          e.preventDefault();\n        });\n        /** @type {?} */\n\n        const touchMoveListener = fromEvent(this.document, 'touchmove', {\n          passive: false\n        }).subscribe(\n        /**\n        * @param {?} touchMoveEvent\n        * @return {?}\n        */\n        touchMoveEvent => {\n          if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) && !isDragActivated && hasContainerScrollbar) {\n            isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n          }\n\n          if ((!this.scrollContainer || !this.scrollContainer.activeLongPressDrag) && !this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n            touchMoveEvent.preventDefault();\n            this.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        });\n\n        this.eventListenerSubscriptions.touchmove =\n        /**\n        * @return {?}\n        */\n        () => {\n          contextMenuListener.unsubscribe();\n          touchMoveListener.unsubscribe();\n        };\n      }\n\n      this.pointerDown$.next({\n        event,\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onTouchEnd(event) {\n      if (this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove();\n        delete this.eventListenerSubscriptions.touchmove;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n          this.enableScroll();\n        }\n      }\n\n      this.pointerUp$.next({\n        event,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    onMouseEnter() {\n      this.setCursor(this.dragCursor);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    onMouseLeave() {\n      this.setCursor('');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    canDrag() {\n      return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    setCursor(value) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    unsubscribeEventListeners() {\n      Object.keys(this.eventListenerSubscriptions).forEach(\n      /**\n      * @param {?} type\n      * @return {?}\n      */\n      type => {\n        this.eventListenerSubscriptions[type]();\n        delete this.eventListenerSubscriptions[type];\n      });\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n\n\n    setElementStyles(element, styles) {\n      Object.keys(styles).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        this.renderer.setStyle(element, key, styles[key]);\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getScrollElement() {\n      if (this.scrollContainer) {\n        return this.scrollContainer.elementRef.nativeElement;\n      } else {\n        return this.document.body;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getScrollPosition() {\n      if (this.scrollContainer) {\n        return {\n          top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n          left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n        };\n      } else {\n        return {\n          top: window.pageYOffset || this.document.documentElement.scrollTop,\n          left: window.pageXOffset || this.document.documentElement.scrollLeft\n        };\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n\n\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n      /** @type {?} */\n      const moveScrollPosition = this.getScrollPosition();\n      /** @type {?} */\n\n      const deltaScroll = {\n        top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n        left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n      };\n      /** @type {?} */\n\n      const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n      /** @type {?} */\n\n      const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n      /** @type {?} */\n\n      const deltaTotal = deltaX + deltaY;\n      /** @type {?} */\n\n      const longPressConfig = this.touchStartLongPress ? this.touchStartLongPress :\n      /* istanbul ignore next */\n      {\n        delta: this.scrollContainer.longPressConfig.delta,\n        delay: this.scrollContainer.longPressConfig.duration\n      };\n\n      if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n        this.timeLongPress.timerBegin = Date.now();\n      }\n\n      this.timeLongPress.timerEnd = Date.now();\n      /** @type {?} */\n\n      const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n      if (duration >= longPressConfig.delay) {\n        this.disableScroll();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    enableScroll() {\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    disableScroll() {\n      /* istanbul ignore next */\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    hasScrollbar() {\n      /** @type {?} */\n      const scrollContainer = this.getScrollElement();\n      /** @type {?} */\n\n      const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n      /** @type {?} */\n\n      const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n      return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n\n  }\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  DraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"mwlDraggable\", \"\"]],\n    inputs: {\n      dragAxis: \"dragAxis\",\n      dragSnapGrid: \"dragSnapGrid\",\n      ghostDragEnabled: \"ghostDragEnabled\",\n      showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n      dragCursor: \"dragCursor\",\n      autoScroll: \"autoScroll\",\n      dropData: \"dropData\",\n      validateDrag: \"validateDrag\",\n      dragActiveClass: \"dragActiveClass\",\n      ghostElementAppendTo: \"ghostElementAppendTo\",\n      ghostElementTemplate: \"ghostElementTemplate\",\n      touchStartLongPress: \"touchStartLongPress\"\n    },\n    outputs: {\n      dragPointerDown: \"dragPointerDown\",\n      dragStart: \"dragStart\",\n      ghostElementCreated: \"ghostElementCreated\",\n      dragging: \"dragging\",\n      dragEnd: \"dragEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return DraggableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nlet DroppableDirective = /*#__PURE__*/(() => {\n  class DroppableDirective {\n    /**\n     * @param {?} element\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} renderer\n     * @param {?} scrollContainer\n     */\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n      this.element = element;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.scrollContainer = scrollContainer;\n      /**\n       * Called when a draggable element starts overlapping the element\n       */\n\n      this.dragEnter = new EventEmitter();\n      /**\n       * Called when a draggable element stops overlapping the element\n       */\n\n      this.dragLeave = new EventEmitter();\n      /**\n       * Called when a draggable element is moved over the element\n       */\n\n      this.dragOver = new EventEmitter();\n      /**\n       * Called when a draggable element is dropped on this element\n       */\n\n      this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      /**\n      * @param {?} drag$\n      * @return {?}\n      */\n      drag$ => {\n        addClass(this.renderer, this.element, this.dragActiveClass);\n        /** @type {?} */\n\n        const droppableElement = {\n          updateCache: true\n        };\n        /** @type {?} */\n\n        const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n        /**\n        * @return {?}\n        */\n        () => {\n          droppableElement.updateCache = true;\n        });\n        /** @type {?} */\n\n        let currentDragDropData;\n        /** @type {?} */\n\n        const overlaps$ = drag$.pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          clientX,\n          clientY,\n          dropData\n        }) => {\n          currentDragDropData = dropData;\n\n          if (droppableElement.updateCache) {\n            droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n\n            if (this.scrollContainer) {\n              droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n            }\n\n            droppableElement.updateCache = false;\n          }\n          /** @type {?} */\n\n\n          const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n\n          if (droppableElement.scrollContainerRect) {\n            return isWithinElement && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);\n          } else {\n            return isWithinElement;\n          }\n        }));\n        /** @type {?} */\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n        /** @type {?} */\n\n        let dragOverActive;\n        overlapsChanged$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        overlapsNow => overlapsNow)).subscribe(\n        /**\n        * @return {?}\n        */\n        () => {\n          dragOverActive = true;\n          addClass(this.renderer, this.element, this.dragOverClass);\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.dragEnter.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlaps$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        overlapsNow => overlapsNow)).subscribe(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlapsChanged$.pipe(pairwise(), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(\n        /**\n        * @return {?}\n        */\n        () => {\n          dragOverActive = false;\n          removeClass(this.renderer, this.element, this.dragOverClass);\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.dragLeave.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        drag$.subscribe({\n          complete:\n          /**\n          * @return {?}\n          */\n          () => {\n            deregisterScrollListener();\n            removeClass(this.renderer, this.element, this.dragActiveClass);\n\n            if (dragOverActive) {\n              removeClass(this.renderer, this.element, this.dragOverClass);\n              this.zone.run(\n              /**\n              * @return {?}\n              */\n              () => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.currentDragSubscription) {\n        this.currentDragSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  DroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n    return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n  };\n\n  DroppableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DroppableDirective,\n    selectors: [[\"\", \"mwlDroppable\", \"\"]],\n    inputs: {\n      dragOverClass: \"dragOverClass\",\n      dragActiveClass: \"dragActiveClass\"\n    },\n    outputs: {\n      dragEnter: \"dragEnter\",\n      dragLeave: \"dragLeave\",\n      dragOver: \"dragOver\",\n      drop: \"drop\"\n    }\n  });\n  /** @nocollapse */\n\n  return DroppableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DragAndDropModule = /*#__PURE__*/(() => {\n  class DragAndDropModule {}\n\n  DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  };\n\n  DragAndDropModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DragAndDropModule\n  });\n  DragAndDropModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return DragAndDropModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa }; //# sourceMappingURL=angular-draggable-droppable.js.map","map":null,"metadata":{},"sourceType":"module"}